#requires imagemagick to run commands
#comment this better later
import sys,os,io
import subprocess
from PIL import Image
from matplotlib.pyplot import imshow
from matplotlib import pyplot as plt
import cv2
import numpy as np
import tkinter 
import tkinter.filedialog
import tkinter.messagebox
import pickle as pkl
import shutil
from shutil import copyfile
import time
class noteimport():
    """Imports pdfs from Sony DPT-RP1 and adds images. 
    
    This class provides a handle for importing a single multipage pdf of
    handwritten notes generated by the Sony DPT-RP1. It may be adapted to 
    other kinds of pdfs but will require some tuning of parameters. Primarily,
    this class scans through the input pdf for any rectangles and then prompts
    the user for a image file to insert at that box. This operation expands the
    filesize of the pdf, so for any pdfs where the box finding operation is not
    required, avoid using this class.

    Args:
        pdfpath {str}: Filepath of the input pdf.
    Attributes:
        pages {list}: List of image objects corresponding to each page of the input.
        outpages {list}: List of image objects corresponding to each page of the output.
    """
    def __init__(self,pdfpath):
        self.pages = []
        self.outpages = []
        os.mkdir("./tempsplit")
        command = 'magick -density 300 -depth 8 -quality 85 "' + pdfpath + '" tempsplit/page-%0d.png'
        process = subprocess.Popen(command, shell=True)
        process.wait()
        pagelist = os.listdir("tempsplit/")
        idxlist = np.array([int(item.split("-")[1][:-4]) for item in pagelist])
        sortlist = np.argsort(idxlist)
        sortedpages = np.array(pagelist)[sortlist].tolist()
        for item in sortedpages:
            pagepath = "tempsplit/" + item    
            imgout = Image.open(pagepath,"r")
            imgout = imgout.convert('RGB')
            self.pages.append(imgout)
        shutil.rmtree("./tempsplit")
    #taken from https://www.pyimagesearch.com/2016/02/08/opencv-shape-detection/
    def __isrectangle(self,contour):
        """Detects if a given conntour is a rectangle.
        
        Uses the Douglas-Peucker algorithm to determine the number of vertices
        in the input contour. Calls a rectangle if there are 4 vertices.
        
        Arguments:
            contour {contour object} -- A single contour object.
        
        Returns:
            bool -- True if the contour is a rectangle.
        """
        peri = cv2.arcLength(contour, True)
        approx = cv2.approxPolyDP(contour, 0.04 * peri, True)
        if len(approx) == 4:
            return True
        else:
            return False
    def __previewrectangle(self,background,rect,xdim=700):
        """Queries the user for image placement.
        
        Displays a detected rectangle to the user and asks the user if they
        would like to place an image at that rectangle.
        
        Arguments:
            background {array} -- Numpy array of the background image.
            rect {list} -- List of coordinates specifying a rectangle [x,y,w,h].
        
        Keyword Arguments:
            xdim {number} -- Width of the preview image. (default: {700})
        
        Returns:
            bool -- True if user wants to place an image.
        """
        a = xdim/background.size[0]
        resized = background.resize((int(background.size[0]*a),int(background.size[1]*a)))
        resized = np.array(resized)
        cv2.rectangle(resized,(int(rect[0]*a),int(rect[1]*a)),(int(rect[0]*a+rect[2]*a),int(rect[1]*a+rect[3]*a)),(0,255,0),2)
        cv2.imshow('Preview',resized)
        query = tkinter.Tk()
        result = tkinter.messagebox.askyesno(title='Prompt',message='Would you like to put an image here?')
        query.destroy()
        return result
    def __getrectangles(self,background,rectanglesize=100000):
        """Detects rectangles in an image.
        
        Detects all rectangles in the input image and records their coordinates
        as a list of [x,y,w,h] lists.
        
        Arguments:
            background {image object} -- PIL image object of the background image.
        
        Keyword Arguments:
            rectanglesize {number} -- Lower bound on the allowed internal area
            of detected rectangles. (default: {100000})
        
        Returns:
            list -- List of rectangle coordinates [x,y,w,h].
        """
        background = cv2.cvtColor(np.array(background),cv2.COLOR_BGR2GRAY)
        thresh = cv2.threshold(background,100,255,1)[1]
        dilate = cv2.dilate(thresh,None,iterations=20)
        _,contours,hierarchy = cv2.findContours(dilate,cv2.RETR_CCOMP,cv2.CHAIN_APPROX_SIMPLE)
        rectangles = []
        for i,cnt in enumerate(contours):
            if hierarchy[0,i,3] == -1 and cv2.contourArea(cnt)>rectanglesize:
                if self.__isrectangle(cnt):
                    x,y,w,h = cv2.boundingRect(cnt)
                    rectangles.append([int(x),int(y),int(w),int(h)])
        return rectangles
    def __maprectangles(self,background,rectangles):
        """Places images in detected rectangles.
        
        Given an image and a list of detected rectangles, places images
        in each of these rectangles. For each rectangle, will query the 
        user for confirmation and a image filepath.
        
        Arguments:
            background {array} -- Numpy array of the background image. 
            rectangles {list} -- List of rectangle coordinates [x,y,w,h].
        
        Returns:
            array -- Numpy array of the background image, with added images.
        """
        root = tkinter.Tk()
        for rect in rectangles:
            usercheck = self.__previewrectangle(background,rect)
            if usercheck:
                targetpath = tkinter.filedialog.askopenfilename(parent=root, initialdir='~', title='Please select a file.')
                targetim = Image.open(targetpath,"r")
                targetim = targetim.convert('RGB')
                targetim = targetim.resize((rect[2],rect[3]))
                background.paste(targetim,(rect[0],rect[1]))
            cv2.destroyAllWindows()
        root.destroy()
        return background
    def addimages(self):
        """Adds images to all pages.
        s
        For each page in self.pages, detects all rectangles in those images,
        queries the user for images to place in those rectangles, and dumps
        the results in self.outpages.
        """
        for page in self.pages:
            rectangles = self.__getrectangles(page)
            self.outpages.append(self.__maprectangles(page,rectangles))
    def saveimages(self,filename):
        """Saves the images in self.outpages as pdfs.
        
        Given an output filepath, saves all images in self.outpages as
        a single pdf at that path.
        
        Arguments:
            filename {str} -- Filepath for saving the output pdf.
        """
        os.mkdir("./temp")
        filelist = []
        for i,page in enumerate(self.outpages):
            page.save("./temp/" + str(i) + ".pdf", "PDF", resolution=72)
            filelist.append(str(i)+".pdf")
        command = "magick -density 72 -depth 8 -quality 85"
        for item in filelist:
            command+=(" ./temp/" + item)
        command+=(" "+filename)
        process = subprocess.Popen(command, shell=True)
        process.wait()
        shutil.rmtree("./temp")

class latexdoc():
    def __init__(self,notebookpath):
        self.notebookpath = notebookpath
    def loadproject(self,title):
        self.title = title
        self.projectpath = self.notebookpath+title+"/"
        self.notesourcepath = self.projectpath+"New_Imagenotes/"
        self.textsourcepath = self.projectpath+"New_Notes/"
        self.notespath = self.projectpath+"Notes/"
        with open((self.projectpath+"notebook.pkl"),"rb") as infile:
            self.texdict = pkl.load(infile)
    def newproject(self,title):
        self.title = title
        self.projectpath = self.notebookpath+title+"/"
        self.notesourcepath = self.projectpath+"New_Imagenotes/"
        self.textsourcepath = self.projectpath+"New_Notes/"
        self.notespath = self.projectpath+"Notes/"
        self.texdict = {"title":title,"notes":[]}
        shutil.rmtree(self.projectpath)
        os.mkdir(self.projectpath)
        os.mkdir(self.notesourcepath)
        os.mkdir(self.textsourcepath)
        os.mkdir(self.notespath)
        with open((self.projectpath+"notebook.pkl"),"wb") as outfile:
            pkl.dump(self.texdict,outfile)
    def updatetitle(self):
        self.texdict["title"] = self.title
        with open((self.projectpath+"notebook.pkl"),"wb") as outfile:
            pkl.dump(self.texdict,outfile)
    def __checkpages(self,pdfpath):
        command = "pdfinfo " + pdfpath + " | grep -a Pages: "
        process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE)
        process.wait()
        line = process.stdout.readline()
        pagenum = int(line.decode('utf-8').split()[1])
        return pagenum
    def addnote(self,newentry,notetitle,keywordlist,date,remove=False): #for handwritten things
        pagenum = len(self.texdict["notes"])
        notename = "note_" + str(pagenum) + ".pdf"
        workingnote = noteimport(self.notesourcepath+newentry)
        workingnote.addimages()
        workingnote.saveimages(self.notespath+notename)
        ttlpages = self.__checkpages(self.notespath+notename)
        self.texdict["notes"].append({"notetitle":notetitle,"keywords":keywordlist,"date":date,"pages":ttlpages})
        self.__sortbydate()
        with open((self.projectpath+"notebook.pkl"),"wb") as outfile:
            pkl.dump(self.texdict,outfile)
        if remove:
            os.remove(self.notesourcepath+newentry)
    def addtext(self,newentry,notetitle,keywordlist,date,remove=False): #for text things
        pagenum = len(self.texdict["notes"])
        notename = "note_" + str(pagenum) + ".pdf"
        shutil.copyfile(self.textsourcepath+newentry,self.notespath+notename)
        ttlpages = self.__checkpages(self.notespath+notename)
        self.texdict["notes"].append({"notetitle":notetitle,"keywords":keywordlist,"date":date,"pages":ttlpages})
        self.__sortbydate()
        with open((self.projectpath+"notebook.pkl"),"wb") as outfile:
            pkl.dump(self.texdict,outfile)
        if remove:
            os.remove(self.textsourcepath+newentry)
    def __sortbydate(self):
        datearr = np.array([np.array(item["date"].split("/")) for item in self.texdict["notes"]]).T
        ind = np.lexsort((datearr[1],datearr[0],datearr[2]))
        for tgt,cur in enumerate(ind):
            currentname = "note_" + str(cur) + ".pdf"
            targetname = "snote_" + str(tgt) + ".pdf"
            os.rename(self.notespath+currentname,self.notespath+targetname)
        for i in range(len(ind)):
            currentname = "snote_" + str(i) + ".pdf"
            targetname = "note_" + str(i) + ".pdf"
            os.rename(self.notespath+currentname,self.notespath+targetname)
        self.texdict["notes"] = (np.array(self.texdict["notes"])[ind]).tolist()        
    def removenote(self,noteindex):
        ttlnotes = len(self.texdict["notes"])
        del self.texdict["notes"][noteindex]
        for i in range(noteindex+1,ttlnotes):
            currentname = "note_" + str(i) + ".pdf"
            targetname = "note_" + str(i-1) + ".pdf"
            os.rename(self.notespath+currentname,self.notespath+targetname)
        self.__sortbydate()
        with open((self.projectpath+"notebook.pkl"),"wb") as outfile:
            pkl.dump(self.texdict,outfile)
    def __latexpage(self,noteidx):
        header = [self.template[26]] + ["\invisiblesection{"+\
        self.texdict["notes"][noteidx]["notetitle"]+"}"] + self.template[28:34]
        body = [" "*20 + "Note: " + self.texdict["notes"][noteidx]["notetitle"] +\
        " " + str(noteidx) + "\\\\"," "*20 + "Date: " + \
        str(self.texdict["notes"][noteidx]["date"]) + "\\\\",\
        " "*20 + "Keywords: " + " ".join(["\\index{" + item.lower() + "}" + item for item in self.texdict["notes"][noteidx]["keywords"]])]
        notepath = self.notespath + "note_" + str(noteidx) + ".pdf"
        closer = self.template[37:41] + ["}]{"+notepath+"}"]
        if self.texdict["notes"][noteidx]["pages"]>1:
            closer += ["\\includepdf[pages=2-]{"+notepath+"}"]
        full =  header+body+closer
        return full
    def __errormsg(self,message):
        root = tkinter.Tk()
        tkinter.Label(root, text=Message).grid(row=0)
        tkinter.Button(root, text='Done', command=root.quit).grid(row=3, column=0, sticky=tkinter.W, pady=4)
        root.mainloop()
        root.destroy()
    def __checkcorruption(self):
        with open((self.projectpath+"notebook.pkl"),"rb") as infile:
            self.texdict = pkl.load(infile)
        dictlen = len(self.texdict["notes"])
        noteslen = len(os.listdir(self.notespath))
        if dictlen != noteslen:
            self.__errormsg("Error: Note number mismatched.")
    def compilelatex(self):
        self.__checkcorruption()
        with open((self.notebookpath+"template.tex"),"r") as infile:
            self.template = infile.read().split("\n")
        textitle = ""
        for item in self.texdict["title"]:
            if item == "_":
                textitle+="\_"
            else:
                textitle+=item
        texlist = self.template[:20] + \
        ["\\title{"+textitle+"}"] + \
        self.template[21:24]
        for i in range(len(self.texdict["notes"])):
            texlist += self.__latexpage(i)
        texlist += self.template[43:45]
        del self.template
        outtex = "\n".join(texlist)
        with open((self.projectpath+"notebook.tex"),"w") as outfile:
            outfile.write(outtex)
    def writepdf(self):
        command = "pdflatex -aux-directory=" + \
        self.projectpath + "notebook_aux " + \
        "-output-directory=" + \
        self.projectpath[:-1] + " " + \
        self.projectpath + "notebook.tex"
        result = subprocess.call(command,shell=False)
    def makeindex(self):
        command = 'makeindex "' + self.projectpath + \
        'notebook_aux/notebook.idx"'
        result = subprocess.call(command,shell=False)
class updateloop():
    def __init__(self,notebookpath):
        self.notebookpath = notebookpath
        self.uncompiled = True 
    def __keyworddatequery(self):
        root = tkinter.Tk()
        tkinter.Label(root, text="Note Title").grid(row=0)
        tkinter.Label(root, text="Keywords (space delimited)").grid(row=1)
        tkinter.Label(root, text="Date (mm/dd/yyyy)").grid(row=2)
        notetitle = tkinter.Entry(root)
        keywords = tkinter.Entry(root)
        date = tkinter.Entry(root)
        notetitle.grid(row=0, column=1)
        keywords.grid(row=1, column=1)
        date.grid(row=2, column=1)
        tkinter.Button(root, text='Done', command=root.quit).grid(row=4, column=0, sticky=tkinter.W, pady=5) ###maybe change pady to 4
        root.mainloop()
        notetitle = notetitle.get()
        keywords = keywords.get()
        date = date.get()
        root.destroy()
        keywords = keywords.split(" ")
        return notetitle,keywords,date
    def __checknewnotes(self,title):
        dochandle = latexdoc(self.notebookpath)
        dochandle.loadproject(title)
        titlepath = self.notebookpath+title+"/"
        for item in os.listdir(titlepath+"New_Imagenotes/"):
            newitem=True
            notetitle,keywords,date = self.__keyworddatequery()
            dochandle.addnote(item,notetitle,keywords,date,remove=True)
        for item in os.listdir(titlepath+"New_Notes/"):
            newitem=True
            notetitle,keywords,date = self.__keyworddatequery()
            dochandle.addtext(item,notetitle,keywords,date,remove=True)
        del dochandle
    def __checkmissing(self,title):
        titlepath = self.notebookpath+title+"/"
        notelist = os.listdir(titlepath+"Notes/")
        noteinds = [int(note.split("_")[1][:-4]) for note in notelist]
        for i in range(len(noteinds)):
            if i not in noteinds:
                dochandle = latexdoc(self.notebookpath)
                dochandle.loadproject(title)
                dochandle.removenote(i)
                del dochandle
                return True
        return False
    def __compileall(self,title):
        dochandle = latexdoc(self.notebookpath)
        dochandle.loadproject(title)
        dochandle.compilelatex()
        dochandle.writepdf()
        dochandle.makeindex()
        dochandle.writepdf()
    def __newproject(self,title):
        dochandle = latexdoc(self.notebookpath)
        dochandle.newproject(title)
    def __updatetitle(self,title):
        dochandle = latexdoc(self.notebookpath)
        dochandle.loadproject(title)
        if dochandle.texdict["title"] != title:
            dochandle.updatetitle()
    def update(self):
        #check all folders
        for title in os.listdir(self.notebookpath):
            compilenotes=False
            if self.uncompiled:
                compilenotes=True
            titlepath = self.notebookpath+title+"/"
            if not os.path.isdir(titlepath):
                continue
            if "notebook.pkl" not in os.listdir(titlepath):
                self.__newproject(title)
            self.__updatetitle(title)
            numnew = len(os.listdir(titlepath+"New_Imagenotes/")) + \
            len(os.listdir(titlepath+"New_Notes/"))
            if numnew>0:
                self.__checknewnotes(title)
                compilenotes=True
            missing = self.__checkmissing(title)
            while missing:
                missing = self.__checkmissing(title)
                compilenotes=True
            if compilenotes:
                self.__compileall(title)
        self.uncompiled=False

if __name__ == '__main__':
    notebookroot = "./"
    uploop = updateloop(notebookroot)
    while True:
        uploop.update()
        time.sleep(1.)